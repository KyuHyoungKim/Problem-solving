## Level 3

- #### 2 x n 타일링
  - ###### 문제 분류 : Dynamic programming
    ###### 점화식 D(n) = D(n-1) + D(n-2)

- #### 타일 장식물
  - ###### 문제 분류 : Dynamic programming
    ###### 점화식 D(n) = D(n-1) + D(n-2)

- #### 이중우선순위큐
  - ###### 문제 분류 : 힙
    ###### 최대 우선순위큐, 최소 우선순위큐 이렇게 2개를 만들고
    ###### 만약 나누어져있지 않았을 떄의 안에 들어있어야 할 원소의 개수를 따로 카운트했다.
    ###### 다른사람 풀이를 보면 

- #### 정수 삼각형
  - ###### 문제 유형 : Dynamic programming
    ###### 문제유형보고 DP에 집착해서 풀었다. 반복되는 계산이 없도록!
    ###### 결과는 결과는 원하는 대로 나오지만, 시간초과에 가독성 떨어지는 코드!!
    ###### 사실 가장 효율적인 방법은 아니었지만, Time complexity가 O(N)인 것 같은데,
    ###### 왜 초과인지 다시 고민해볼 갓
    ###### 그리고 그 코드도 결국 모든 지점을 1번씩 전부 계산을 하기 때문에
    ###### 그냥 바로 더해주는 방법으로 다시 접근해서 풀었다.
    
- #### 예산
  - ###### 신청 예산 정렬
    ###### 모든 신청 예산을 더한 후 예산 총액과 비교
    ###### 예산 총액이 더 크면 신청 예산 중 가장 큰 것 반환,
    ###### 예산이 모자란 경우 신청 예산이 가장 큰 것부터 예산 삭감하는 방식으로 접근해 풀이
  - ###### 도시의 개수의 최대 값 : 100,000 / 신청 예산의 최대값 : 100,000
    ###### 모든 신청 예산을 더한 경우가 int형의 범위를 넘는 경우가 테스트 케이스 중에 하나가 있음
    ###### 그래서 합을 저장하는 변수 sum을 int형에서 long long 형으로 변경해 풀이

- #### 섬 연결하기
  - ###### 임의로 시작 노드를 정해 Prim 알고리즘으로 풀이
  - ###### 추후 크루스칼 알고리즘으로 다시 풀이할 예정

- #### 베스트앨범
  - ###### map container로 같은 장르의 정보들(전체 재생 수, 재생 수 목록, 인덱스) 통합
  - ###### 전체 재생수로 정렬해 장르의 순서를 정한 후 장르 내 곡마다의 재생 수를 정렬해 수록곡 선정

- #### 디스크 컨트롤러
  - ###### mean heap으로, 현재 시간에서 시작 가능한 모든 작업 중 소요시간이 가장 작은 것 부터 실행(Greedy)
