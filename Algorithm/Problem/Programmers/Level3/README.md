## Level 3

- #### 2 x n 타일링
  - ###### 문제 분류 : Dynamic programming
    ###### 점화식 D(n) = D(n-1) + D(n-2)

- #### 타일 장식물
  - ###### 문제 분류 : Dynamic programming
    ###### 점화식 D(n) = D(n-1) + D(n-2)

- #### 이중우선순위큐
  - ###### 문제 분류 : 힙
    ###### 최대 우선순위큐, 최소 우선순위큐 이렇게 2개를 만들고
    ###### 만약 나누어져있지 않았을 떄의 안에 들어있어야 할 원소의 개수를 따로 카운트했다.
  - ##### 20200831
    ###### multiset 활용해 풀이

- #### 정수 삼각형
  - ##### 문제 유형 : Dynamic programming
    ###### 문제유형보고 DP에 집착해서 풀었다. 반복되는 계산이 없도록!
    ###### 결과는 결과는 원하는 대로 나오지만, 시간초과에 가독성 떨어지는 코드!!
    ###### 사실 가장 효율적인 방법은 아니었지만, Time complexity가 O(N)인 것 같은데,
    ###### 왜 초과인지 다시 고민해볼 갓
    ###### 그리고 그 코드도 결국 모든 지점을 1번씩 전부 계산을 하기 때문에
    ###### 그냥 바로 더해주는 방법으로 다시 접근해서 풀었다.
  - ##### 20200901
    ###### 삼각형의 모든 부분을 돌면서 해당 자리로 올 수 있는 칸 2개 중 큰것과 그 자리의 값을 더한 것을 메모이제이션

- #### 예산
  - ###### 신청 예산 정렬
    ###### 모든 신청 예산을 더한 후 예산 총액과 비교
    ###### 예산 총액이 더 크면 신청 예산 중 가장 큰 것 반환,
    ###### 예산이 모자란 경우 신청 예산이 가장 큰 것부터 예산 삭감하는 방식으로 접근해 풀이
  - ###### 도시의 개수의 최대 값 : 100,000 / 신청 예산의 최대값 : 100,000
    ###### 모든 신청 예산을 더한 경우가 int형의 범위를 넘는 경우가 테스트 케이스 중에 하나가 있음
    ###### 그래서 합을 저장하는 변수 sum을 int형에서 long long 형으로 변경해 풀이

- #### 섬 연결하기
  - ###### 임의로 시작 노드를 정해 Prim 알고리즘으로 풀이
  - ###### 추후 크루스칼 알고리즘으로 다시 풀이할 예정
  - ##### 20200931
    ###### 크루스칼 알고리즘으로 풀이

- #### 베스트앨범
  - ###### map container로 같은 장르의 정보들(전체 재생 수, 재생 수 목록, 인덱스) 통합
  - ###### 전체 재생수로 정렬해 장르의 순서를 정한 후 장르 내 곡마다의 재생 수를 정렬해 수록곡 선정

- #### 디스크 컨트롤러
  - ###### mean heap으로, 현재 시간에서 시작 가능한 모든 작업 중 소요시간이 가장 작은 것 부터 실행(Greedy)

 - #### 단속카메라
  - ##### 20200901
    ###### 진출지점을 기준으로 오름차순 정렬 후, 진출지점에 카메라 설치
    ###### 설치한 카메라 위치에 걸리는 차량 확인
    ###### 카메라에 안잡히는 차량 중 진출지점이 제일 작은 것의 진출지점에 카메라 설치 -반복
  - ###### 정답처리 되긴 했는데, 정말 맞는 것인지 의문이 든다. 프로그래머스는 테케가 부족하다는 생각이 자주 듦

 - #### N으로 표현
  - ##### 20200901
    ###### DP로 카테고라이징 되어 있는데 완전 나이브하게 풀이
    ###### 이것도 정답은 받았는데.. 테케 많이 넣으면 시간초과날것같은..
    ###### 이것도 의심스럽다

 - #### 등굣길
  - ##### 20200901
    ###### 맞긴맞았다. 문제에서 갈 수 이쓴 최단경로의 개수를 구하라는데에서,
    ###### 오른쪽과 아랫쪽으로만 이동하는 경우를 구하라는거구나 싶긴한데,
    ###### 엄밀하게 따지면, 위나 왼쪽으로 이동해야만 하는 케이스를 만들 수 있을 것 같아서 문제가 맘에 안든다.

 - #### 네트워크
  - ##### 20200901
    ###### DFS/BFS로 분류되어있는 문제지만, union-find로 풀이했다.
    ###### 출제자가 의도한 풀이는 DFS/BFS를 반복하면서 네트워크의 개수를 카운트 하는 것 같긴 하다.
    