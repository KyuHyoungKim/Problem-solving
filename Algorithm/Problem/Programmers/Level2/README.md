## Level 2

- #### 주식가격
  - ###### 문제 유형 : 스택/ 큐
  - ###### 처음에는 prices의 각 원소마다 prices를 순회하며 떨어지는 위치를 찾는 방식으로 접근
    ###### 모두가 끝까지 가격이 안떨어지는 경우 Time complexity는 n-1 + n-2 + ... + 2 + 1 로 O(n^2)
  - ###### 다른사람 풀이에서 Stack을 사용하는 접근 방식을 참고하여 다시 풀어보았다.
    ###### stack STL 문법, stack \<int\> Stack; Stack.top(), Stack.pop(), Stack.push()
    ###### 처음엔 생각하지 못했던 것 : 
    ###### 아직 가격이 떨어지지 않은 것들 중에서 순서상 뒤에 있는 것들이 앞에 있는 것들보다 항상 크거나 같다.
    ###### It means 바로 앞에 있는 것과 비교 후 앞에있는게 안떨어지면 앞에 있는 것들도 안떨어진다! 
    ###### => stack에 시간 흐름을 점차 쌓아놓고 떨어진게 있을 때, 하나씩 점검하며 흐른 시간들을 저장하고 pop!

- #### 프린터
  - ###### 문제 유형 : 스택/ 큐
  - ###### 대놓고 Queue를 쓰라고하는 문제
    ###### priorities를 정렬한 vector를 하나 따로 만들었음 -> 최대값인지 확인하는 비교연산 횟수를 줄이고싶어서
      ###### 다 풀고 생각해보니, 정렬할 때 하는 연산 횟수와 비교했을 때 그리 의미있는 방법은 아닌 것 같음.
      ###### 오히려 메모리 낭비였지 싶다.
    ###### queue에 priority의 모든 원소를 push하고, 정렬되어있는 priorities 원소와 비교하여 프린트 할지말지 여부 결정
    ###### Queue 문법, queue \<int\> Queue, Queue.front(), Queue.pop(), Queue.push()
  - ###### 다른사람 풀이 참고한 부분
    ###### 전체적으로 유사하나 queue에 index를 넣음
    ###### \*max_element(A.begin(),A.end()) : algorithm 헤더 안에 있음, 포인터를 반환함
    ###### 주식가격 문제도 그렇고 stack, queue에는 주로 인덱스, 시간 등을 넣어서 사용하는 것 같다.

- #### 기능개발
  - ###### 문제 유형 : 스택/ 큐

- #### 124 나라의 숫자

- #### 탑
  - ###### 문제 유형 : 스택/ 큐

- #### 쇠막대기
  - ###### 문제 유형 : 스택/ 큐

- #### 스킬트리
  - ###### for(int j = 0; j < vector.size()-1 ; j++){ ~ }
    ###### vector가 비어있을 때, 즉 vector.size()-1이 -1일 때 반복문 내부가 실행이 안되어야 하는데, 실행이 된다!!
    ###### 이거 때문에 시간을 많이 썼다.
    ###### 원인은 vector.size()의 반환형이 unsigned_int였다는거
    ###### unsigned_int의 0에서 1을 빼니 엄청 큰 양수가되는 것이었다.
    ###### 크게 하나 배웠다..

- #### 가장 큰 수
  - ###### 문제 유형 : 정렬
  - ###### 처음엔 숫자들을 string으로 바꾸고, 정렬하고 합치는 것으로 접근
  - ###### 3과 30이 이을 때 330이 되지 않고 303이 되는 문제 발생
    ###### compare을 따로 정의해 진행
    ###### compare(string& a, string& b){return a + b > b + a}
  - ###### 추가로 모든 수가 0인 경우 00000000이 아닌 0이 출력되도록 예외처리

- #### 큰 수 만들기
  - ###### 문제 유형 : Greedy
  - ###### str.erase(a,b) 문법 : str의 index a 부터 b 개 만큼 삭제

- #### 다리를 지나는 트럭
  - ###### 문제 유형 : 스택 / 큐
  - ###### 다리를 건너고 있는 트럭들을 큐에 푸쉬 queue\<int\> on_bridge;
  - ###### 다리를 다 건넌 트럭의 수를 세는 int done을 사용
  - ###### 인덱스 오류
    ###### done + on_bridge.size()를 인덱스로 사용
    ###### 대기중인 트럭이 없을 때 done+on_bridge.size()가 모든 트럭의 수가됨

- #### 더 맵게
  - ###### 문제 유형 : 힙
  - ###### 계속해서 최소값을 찾고 반환해야하는 문제
    ###### 처음엔 sort함수로 한번 정렬하고 뒤에 계산해서 나온 새로운 값만 자리를 찾아서 넣어줬는데
    ###### 시간초과가 났다.
    ###### 하는 수 없이, 우선순위큐로 다시 풀이

- #### H-Index
  - ###### 문제 유형 : 정렬
    ###### 나중에 다시 한번 더 풀어볼 것

- #### 전화번호 목록
  - ###### 문제 유형 : 해시
  - ###### 그냥 string의 find함수로 풀어버렸다.
  
- #### 카펫
  - ###### 문제 유형 : 완전탐색

- #### 소수찾기
  - ###### 문제 유형 : 완전탐색
  - ###### 주어진 numbers를 내림차순 정렬해 만들 수 있는 가장 큰 수를 도출하고,
    ###### 그 수까지의 모든 소수를 찾고 numbers로 만들 수 있는 소수인지 확인

- #### 괄호변환
  - ###### 문제에서 시키는대로 재귀(Recursion)을 하면 되는 문제
  - ###### u에서 첫 번째와 마지막 문자를 제외하고 뒤집으라는 것을 순서를 뒤집으라는 것으로 잘못이해해 시간을 허비했다.
    ###### 잘 읽자..

- #### 올바른 괄호

- #### 피보나치 수
  - ###### 조건의 n이 100,000까지 가능하므로 효율성을 위해 DP로 접근

- #### 최솟값 만들기

- #### 최댓값과 최솟값
  - ###### strtok
    ###### c++의 string를 c의 strtok함수를 통해 tokenize해서 string 안의 정수들을 추출
    ###### c의 strtok함수는 string 클래스를 못받고 char\*을 받기 때문에, string을 char\*로 변환하는 과정이 필요했다. 
    ###### 찾아보니 string을 char의 문자열로 변환하는 함수는 string.data()함수와 string.c_str()함수가 있는데,
    ###### data함수는 string 안의 내용을 그대로 복사해주고, c_str()함수는 c의 문자열 처럼 마지막에 널 문자를 붙여준다.
    ###### 그렇기 때문에 c의 함수를 사용하기 위해 string을 변환하는 경우 c_str()이 선호됨
    ###### data함수와 c_str함수 모두 const char\*을 반환하는데, strtok는 char\*를 받기 때문에,
    ###### char\*에 string의 사이즈+1만큼 동적할당 해주고 strcpy로 내용을 복사해서 사용했다.
    
- #### 숫자의 표현
  - ###### 완전탐색으로 풀었다.
    ###### solution function의 input n은 10000 이하의 수,
    ###### 만약 Time complexity가 O(n^2) 이라면, 기본 1억회
    ###### 하지만, 1부터 n'의 합이 10000이 되는 지점은 10000보다 훨씬 작을 것,
    ###### 그러므로 완전탐색을 해도 연산횟수가 그리 많지 않을 것이다! 라고 판단.
  
- #### 다음 큰 숫자

- #### N개의 최소공배수
  - ###### 유클리드 호제법

- #### 크레인 인형뽑기 게임
  - ###### 스택으로 풀이 

- #### 소수 만들기
  - ###### 풀이 설명
    ###### nums를 내림차순으로 정렬하고 만들 수 있는 가장 큰 수 max를 도출
    ###### max+1 개수의 원소를 갖는 boolean vector를 만듦
    ###### 에라토스테네스의 체 알고리즘으로 boolean vector의 소수의 인덱스를 갖는 부분만 true값을 갖게한다.
    ###### nums의 조합들을 모두 구하면서 그 값을 인덱스로 하는 boolean vector에서 true면 answer++
  - ###### 코드는 꽤 깔끔해보이나, 3중 for문을 사용해서 뭔가 찜찜하다
    ###### 조합을 구하는 더 나은 알고리즘이나, 함수가 잇는지 알아보자
    
- #### 영어 끝말잇기
  - ###### 단어의 개수가 적어서 완전탐색으로 풀이
  - ###### 다른사람 풀이 : map 사용
    ###### word를 key로 true와 함께 저장하고 다음 word를 key로 탐색
    ###### map은 균형 이진트리를 기반으로 구현되어있다.
    ###### 속도차이는?? -> 찾아볼 것

- #### 예상 대진표
  - ###### 한라운드가 지날 때마다 배정받는 번호 a는 a/2 + a%2가 된다.

- #### 행렬의 곱셈

- #### 라면공장
  - ###### 처음 풀이 (ver_fail)
    ###### 현재 일자를 int형 변수로 선언,
    ###### 현재 일자부터 stock으로 버틸 수 있는 일수 동안의 가장 큰 supplies를 선택,
    ###### stock에 supply를 더하고, 현재 일자를 공급일자로 이동, stock에서 이동한 만큼(사용한 만큼) 뺌
    ###### 현재일자에서부터 버틸 수 있는 일자 동안의 가장 큰 supplies를 선택 -> 반복
    ###### 문제점 : 큰 공급이 모여있는 경우 넘어감, 최악의 경우 Time complexity : O(N^2)
  - ###### 나중풀이
    ###### 생각해보니 현재일자를 따로 저장할 필요가 없음 그리고 여유로워도 supply가 크면 해야함
    ###### Heap으로 접근해서 

- #### [3차] 방금그곡
  - ###### 풀이
    ###### 1. 음악 재생시간 구하고, 현재까지 조건에 일치하는 가장 길었던 음악의 재생시간과 비교,
      ###### 길이가 더 짧으면 조건에 맞아도 답이 되진 않으니 패스
    ###### 2. musicinfos에 있는 악보를 string Note로 추출, 그리고 Note와 m의 \#이 붙은 음들을 모두 소문자로 치환
    ###### 3. 음악 재생시간과 Note 길이를 비교후 처리
    ###### 4. 조건에 맞는지 확인
  - ###### 실수
    ###### 1. Note를 연장하려고 Note+=Note를 하면서 길이가 기하급수적으로 늘어나게하는 실수로 시간낭비
    ###### 2. 문제 이해가 늦어 재생 시간이 악보 길이보다 짧을 때를 처리하지 않아 시간낭비
  
- #### 점프와 순간이동
  - ###### 복합대입연산자(+= -= 등)와 증감연산자(a-- ++a 등)가 차이가 없다고 생각했는데, 프로그래머스
    ###### n-=1;을 사용했을 때 시간 초과였던 것이 증감연산자로 바꾸니 통과했다
    ###### 검색해서 나온 정보로는, n-=1은 메모리 접근이 3회 일어나고 --n은 메모리 접근이 2회 일어나기 때문이라고 한다.
    ###### 그런데, 옛날 컴파일러나 그렇고 요즘 것들은 똑같다고 한다.
    ###### 추가로 증감 연산자를 사용할 때, 그냥 integer 정수 같은 것은 전위나 후위나 성능면에서 차이가 없지만,
    ###### 객체에 사용할 경우 할당하는 것이 부담이 되어 전위연산자가 성능면에서 우위를 점한다고 한다.

- #### 구명보트
  - ###### 내림차순 정렬 -> 값이 큰 것 채움 -> 작은 것 채움
    ###### 문제에서 주어진 상황에서는 Deque을 사용하는 것 보다는 큰 값의 인덱스와 작은 값의 인덱스를 정수형 변수로 저장하는 것이 효율적일 것으로 판단되어, int Front와 int End를 선언해서 문제 풀이

- #### 폰켄몬

- #### 멀쩡한 사각형
  - ###### 일단 주어진 수가 크고, w와 h의 최대공약수 만큼 반복이 되는 문제이기 때문에, w와 h를 최대공약수로 나누는 것을 기본으로 두고 풀이했다.
  - ##### 1차시도
    ###### w와 h 중에 긴 것을 짧은 것으로 나눈 값을 올림한 것이 한 행 또는 열에서 사용할 수 없는 사각형의 개수라고 생각했다.
    ###### 그렇게 계산한 개수에 짧은 길이를 곱해서 계산했는데, 테스트케이스 중 절반만 맞음
    ###### 고민해보니 항상 같은 개수만큼이 아님을 알게됨. ex) w = 10, h = 27    
  - ##### 2차시도
    ###### w * h의 사각형의 한 꼭지점에서 대각선으로 반대쪽 사각형으로 이동하는 것을 좌표의 관점으로 바라봤을 때,
    ###### w만큼 오른쪽으로 이동해야하고, h만큼 아래로도 이동해야한다.
    ###### 그런데 시작지점이 겹치기 때문에 w+h-1만큼의 네모를 사용할 수 없다. (최대공약수로 나눈 것 기준)
    ###### 결론은 answer = w * h - (w + h - gcd);

- #### 튜플
  - ###### string으로 주어진 input을 vector<vector<int>>로 변환 -> vector의 사이즈를 기준으로 오름차순 정렬 
    ###### -> 정렬된 vector들을 탐색하며 새로 나타난 원소를 answer에 push
  - ###### Tuple의 최대 원소 개수가 500개이기 때문에, O(N^2)으로도 괜찮다고 판단 -> 새로 나타난 원소를 찾을 때 2중 반복문을 사용했음

- #### 카카오프렌즈 컬러링북
  - ###### 보면 바로 BFS 문제구나 라는 것이 떠오르지만, 아직 BFS가 친숙하진 않아서 우선은 당장 떠오른 방식으로 풀이
  - ##### 1. 재귀와 탐색
    ###### 값이 0이 아니면서, 방문하지 않은 점을 탐색 -> 조건에 부합하는 점을 발견 시 Area를 count하고, 그 점의 사방을 탐색해서 조건 확인
    ###### queue를 사용하지 않고 Recursion을 사용했지만, 힘수가 시작할 때 방문처리를 해서 queue인 것 처럼 처리했다.
  - ##### 추후 BFS로 풀이해볼 예정
  
  - #### 문자열 압축
  - ###### 두 번째 반목문의 조건을 j < s.size()에서 j<=s.size()로 바꾸니 통과
    ###### 반복문 안에서 j가 사용되는 부분은 s.substr(j,i) 뿐이라, 인덱스 오류는 나지 않는다.
    ###### 그런데, 저렇게 바꾸었는데 결과가 바뀌었다는건, 반복문이 1번 더 실행되어야 하는 케이스가 있었다는건데
    ###### 아무리 생각해도 그 케이스를 모르곘다.
    
- #### [1차] 뉴스 클러스터링
  - ##### 1차 풀이
    ###### 알파벳인지 확인하고, 알파벳이면 전부 소문자로 변환해서 풀이
  - ##### 2차 풀이
    ###### 다른사람 코드를 리딩해보다 대소문자를 따로 구분하지 않고, 비트연산자 활용하는 것을 봄
    ###### 아스키코드 표를 보니 대문자는 2^6 + 1부터 시작하고, 소문자는 2^6 + 2^5 + 1부터 시작함을 알수있었음
    ###### 알파벳 a로 예를들어 다르게 설명하면 
    ###### A는 비트로 ...0100001
    ###### a는 비트로 ...1100001
    ###### 즉 31 & A = 1, 31 & a = 1
    ###### 개꿀팁이었다.
  - ###### 추가로, 난 인덱스를 첫 번째 문자에 100을 곱하고 두번째문자를 더했는데, 대부분 26을 곱한다.
    
- #### 단체사진 찍기
  - ##### 모든 경우의 수가 8! (약 4만) 이므로 순열로 모든 경우의 수를 체크
  - ##### 1차 풀이 (시간초과)
    ###### 재귀로 순열 직접 구현해서 풀이
  - ##### 2차 풀이
    ###### 조건 확인하는 것 때문에, dp는 사용할 수 없어서 시간초과를 어떻게 해결할지 감이 안잡혀 다른사람 풀이 참고
    ###### STL에 순열 또는 조합에 유용한 next_permutaion과 previous_permutation이라는 함수가 있다는 것을 알게 됨
    ###### 출력 데이터형 : bool -> Input을 다음 순열로 바꾸고 true 반환,
    ###### 더 이상 다음 순열을 찾을 수 없으면 false 반환
    
- #### 타켓 넘버
  - ##### 주어지는 numbers의 최대 개수 20개 => 최대 경우의 수 2^20 => 약 10^6이므로 완전 탐색으로 접근 가능
    ##### 완전탐색을 재귀로 구현하여 풀이

- #### 가장 큰 정사각형 찾기
  - ##### 1차 풀이 (시간초과)
    - ##### 다른 풀이 방법이 떠오르지 않아 완전탐색으로 풀이
      ###### 주어진 배열의 행과 열 중 짧은 것을 기준으로 크기가 큰 정사각형부터 확인
      ###### 모든 지점을 돌며 0인 것이 발견되었을 때 3가지 경우로 나누어 재귀
      ###### 1. 옆으로 한칸 움직여도 현재 찾는 크기의 정사각형이 나올 수 있을 때 옆으로 한칸 움직여서 다시 탐색
      ###### 2. 옆으로 움직이면 찾는 크기의 정사각형이 만들어지지 않고, 아래로 이동했을 때 만들어지는 경우 아래로 한칸 이동
      ###### 3. 위로 아래로도 움직일 수 없는 경우 정사각형의 변의 길이를 1 줄이고, (0,0)에서부터 다시 탐색
      ###### 최대 1000 * 1000 배열이고, 시간복잡도가 O(n^3)이기 때문에 예상한대로 시간초과로 실패
  - ##### 2차 풀이 (Dynamic Programming)
    - ##### 혼자 고민했을 때는 떠올리지 못하고 다른 사람들 코드 참고하였음
      ###### 변의 길이가 2인 정사각형을 기준으로 우측 아래의 점을 기준으로 삼는다.
      ###### 기준점이 0이 아닐 때, 좌측, 위측, 왼쪽위 대각선을 확인해 가장 작은 것에 1을 더한 것을 기준점에 덮어쓴다. (DP)
      ###### 그렇게 (N-1)(N-1)번 탐색을 하고 가장 큰 값이 가장 큰 정사각형의 변의 길이이다.
      ###### 그림을 그려보면 이게 어떻게 성립되는지 쉽게 이해할 수 있다.

- #### 위장
  - ##### 백준 9375번:패션왕 같은문제
  - ##### 풀이 공통부문
    ###### 같은종류의 옷 중 같은 이름은 없다 -> map 자료구조 선택(key : 종류, value : 개수)
  - ##### 1차 풀이(시간 초과)
    ###### 반복자를 이용해 모든 종류를 탐색하며 해당 종류를 선택한 경우와 선택하지 않은 경우의 수를 탐색
    ###### 재귀함수로 구현
    ###### 경우의 수 : 선택된 종류의 옷의 개수들의 곱
    ###### 최대 인풋의 개수 30개가 모두 다른 종류일 경우 2^30의 경우의 수 -> 시간초과
  - ##### 2차 풀이
    ###### 종류별 옷의 개수에 안입은 경우를 추가해 개수 + 1을 모두 곱한 후 아무 것도 안입은 경우인 1개의 경우의 수를 뺌

- #### 땅따먹기
  - ##### 백준 1149번:RGB거리와 같은문제
  - ##### 풀이 공통부문
    ###### 같은종류의 옷 중 같은 이름은 없다 -> map 자료구조 선택(key : 종류, value : 개수)
  - ##### 이전 풀이(시간 초과)
    ###### 재귀적으로 완전탐색 구현 -> 경우의 수 4의 100,000승 => 무조건 시간초과
  - ##### 풀이
    ###### Dynamic programing
    ###### land와 같은 크기의 dp 어레이에 이전행의 다른자리의 가장 큰 값에 현재행과 열의 land값을 더한 것을 저장
    ###### 마지막 행까지 계산 후, 마지막행에서 가장 큰 값 도출
    ###### 행의 개수 : N, 열의 개수 : M이라고하면 N*M의 시간복잡도 => (4^N)보다 훨씬 작음

- #### 조이스틱
  - ##### Greedy
  - ###### 왼쪽, 오른쪽 중 더 가까운 바꾸어야할 위치로 이동 후 변환

- #### 숫자 야구
  - ##### Greedy
  - ###### 모든 숫자를 돌며 현재의 숫자가 답인 경우에 주어진 질의에서 같은 결과(strike/ball)가 나오는지 확인