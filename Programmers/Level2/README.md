## Level 2

- #### 주식가격
  - ###### 문제 유형 : 스택/ 큐
  - ###### 처음에는 prices의 각 원소마다 prices를 순회하며 떨어지는 위치를 찾는 방식으로 접근
    ###### 모두가 끝까지 가격이 안떨어지는 경우 Time complexity는 n-1 + n-2 + ... + 2 + 1 로 O(n^2)
  - ###### 다른사람 풀이에서 Stack을 사용하는 접근 방식을 참고하여 다시 풀어보았다.
    ###### stack STL 문법, stack \<int\> Stack; Stack.top(), Stack.pop(), Stack.push()
    ###### 처음엔 생각하지 못했던 것 : 
    ###### 아직 가격이 떨어지지 않은 것들 중에서 순서상 뒤에 있는 것들이 앞에 있는 것들보다 항상 크거나 같다.
    ###### It means 바로 앞에 있는 것과 비교 후 앞에있는게 안떨어지면 앞에 있는 것들도 안떨어진다! 
    ###### => stack에 시간 흐름을 점차 쌓아놓고 떨어진게 있을 때, 하나씩 점검하며 흐른 시간들을 저장하고 pop!

- #### 프린터
  - ###### 문제 유형 : 스택/ 큐
  - ###### 대놓고 Queue를 쓰라고하는 문제
    ###### priorities를 정렬한 vector를 하나 따로 만들었음 -> 최대값인지 확인하는 비교연산 횟수를 줄이고싶어서
      ###### 다 풀고 생각해보니, 정렬할 때 하는 연산 횟수와 비교했을 때 그리 의미있는 방법은 아닌 것 같음.
      ###### 오히려 메모리 낭비였지 싶다.
    ###### queue에 priority의 모든 원소를 push하고, 정렬되어있는 priorities 원소와 비교하여 프린트 할지말지 여부 결정
    ###### Queue 문법, queue \<int\> Queue, Queue.front(), Queue.pop(), Queue.push()
  - ###### 다른사람 풀이 참고한 부분
    ###### 전체적으로 유사하나 queue에 index를 넣음
    ###### \*max_element(A.begin(),A.end()) : algorithm 헤더 안에 있음, 포인터를 반환함
    ###### 주식가격 문제도 그렇고 stack, queue에는 주로 인덱스, 시간 등을 넣어서 사용하는 것 같다.

- #### 기능개발
  - ###### 문제 유형 : 스택/ 큐

- #### 124 나라의 숫자

- #### 탑
  - ###### 문제 유형 : 스택/ 큐

- #### 쇠막대기
  - ###### 문제 유형 : 스택/ 큐

- #### 스킬트리
  - ###### for(int j = 0; j < vector.size()-1 ; j++){ ~ }
  - ###### vector가 비어있을 때, 즉 vector.size()-1이 -1일 때 반복문 내부가 실행이 안되어야 하는데, 실행이 된다!!
  - ###### 이거 때문에 시간을 많이 썼다.
  - ###### 원인은 vector.size()의 반환형이 unsigned_int였다는거
  - ###### unsigned_int의 0에서 1을 빼니 엄청 큰 양수가되는 것이었다.
  - ###### 크게 하나 배웠다..

- #### 가장 큰 수
  - ###### 문제 유형 : 정렬
  - ###### 처음엔 숫자들을 string으로 바꾸고, 정렬하고 합치는 것으로 접근
  - ###### 3과 30이 이을 때 330이 되지 않고 303이 되는 문제 발생
  - ###### compare을 따로 정의해 진행
  - ###### compare(string& a, string& b){return a + b > b + a}
  - ###### 추가로 모든 수가 0인 경우 00000000이 아닌 0이 출력되도록 예외처리

- #### 큰 수 만들기
  - ###### 문제 유형 : Greedy
  - ###### str.erase(a,b) 문법 : str의 index a 부터 b 개 만큼 삭제

- #### 다리를 지나는 트럭
  - ###### 문제 유형 : 스택 / 큐
    ###### 다리를 건너고 있는 트럭들을 큐에 푸쉬 queue\<int\> on_bridge;
    ###### 다리를 다 건넌 트럭의 수를 세는 int done을 사용
    ###### done + on_bridge.size()를 인덱스로 사용했으나
    ###### 대기중인 트럭이 없을 때 done+on_bridge.size()가 모든 트럭의 수가됨
    ###### 이로인한 인덱스 오류로 시간좀 썼다.

- #### 더 맵게
  - ###### 문제 유형 : 힙
    ###### 계속해서 최소값을 찾고 반환해야하는 문제
    ###### 처음엔 sort함수로 한번 정렬하고 뒤에 계산해서 나온 새로운 값만 자리를 찾아서 넣어줬는데
    ###### 시간초과가 났다.
    ###### 하는 수 없이, 우선순위큐로 다시 풀이

- #### H-Index
  - ###### 문제 유형 : 정렬
    ###### 나중에 다시 한번 더 풀어볼 것

- #### 전화번호 목록
  - ###### 문제 유형 : 해시
  - ###### 그냥 string의 find함수로 풀어버렸다.
  
- #### 카펫
  - ###### 문제 유형 : 완전탐색

- #### 소수찾기
  - ###### 문제 유형 : 완전탐색
    ###### 주어진 numbers를 내림차순 정렬해 만들 수 있는 가장 큰 수를 도출하고,
    ###### 그 수까지의 모든 소수를 찾고 numbers로 만들 수 있는 소수인지 확인

- #### 괄호변환
  - ###### 문제에서 시키는대로 재귀(Recursion)을 하면 되는 문제
    ###### u에서 첫 번째와 마지막 문자를 제외하고 뒤집으라는 것을 순서를 뒤집으라는 것으로 잘못이해해 시간을 허비했다.
    ###### 잘 읽자..

- #### 올바른 괄호
