- #### 주식가격
  - ###### 문제 유형 : 스택/ 큐
  - ###### 처음에는 prices의 각 원소마다 prices를 순회하며 떨어지는 위치를 찾는 방식으로 접근
    ###### 모두가 끝까지 가격이 안떨어지는 경우 Time complexity는 n-1 + n-2 + ... + 2 + 1 로 O(n^2)
  - ###### 다른사람 풀이에서 Stack을 사용하는 접근 방식을 참고하여 다시 풀어보았다.
    ###### stack STL 문법, stack \<int\> Stack; Stack.top(), Stack.pop(), Stack.push()
    ###### 처음엔 생각하지 못했던 것 : 
    ###### 아직 가격이 떨어지지 않은 것들 중에서 순서상 뒤에 있는 것들이 앞에 있는 것들보다 항상 크거나 같다.
    ###### It means 바로 앞에 있는 것과 비교 후 앞에있는게 안떨어지면 앞에 있는 것들도 안떨어진다! 
    ###### => stack에 시간 흐름을 점차 쌓아놓고 떨어진게 있을 때, 하나씩 점검하며 흐른 시간들을 저장하고 pop!

- #### 프린터
  - ###### 문제 유형 : 스택/ 큐
  - ###### 대놓고 Queue를 쓰라고하는 문제
    ###### priorities를 정렬한 vector를 하나 따로 만들었음 -> 최대값인지 확인하는 비교연산 횟수를 줄이고싶어서
      ###### 다 풀고 생각해보니, 정렬할 때 하는 연산 횟수와 비교했을 때 그리 의미있는 방법은 아닌 것 같음.
      ###### 오히려 메모리 낭비였지 싶다.
    ###### queue에 priority의 모든 원소를 push하고, 정렬되어있는 priorities 원소와 비교하여 프린트 할지말지 여부 결정
    ###### Queue 문법, queue \<int\> Queue, Queue.front(), Queue.pop(), Queue.push()
  - ###### 다른사람 풀이 참고한 부분
    ###### 전체적으로 유사하나 queue에 index를 넣음
    ###### \*max_element(A.begin(),A.end()) : algorithm 헤더 안에 있음, 포인터를 반환함
    ###### 주식가격 문제도 그렇고 stack, queue에는 주로 인덱스, 시간 등을 넣어서 사용하는 것 같다.

- #### 기능개발
  - ###### 문제 유형 : 스택/ 큐

- #### 124 나라의 숫자

- #### 탑
  - ###### 문제 유형 : 스택/ 큐

- #### 쇠막대기
  - ###### 문제 유형 : 스택/ 큐

