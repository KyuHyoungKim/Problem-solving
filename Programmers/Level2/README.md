## Level 2

- #### 주식가격
  - ###### 문제 유형 : 스택/ 큐
  - ###### 처음에는 prices의 각 원소마다 prices를 순회하며 떨어지는 위치를 찾는 방식으로 접근
    ###### 모두가 끝까지 가격이 안떨어지는 경우 Time complexity는 n-1 + n-2 + ... + 2 + 1 로 O(n^2)
  - ###### 다른사람 풀이에서 Stack을 사용하는 접근 방식을 참고하여 다시 풀어보았다.
    ###### stack STL 문법, stack \<int\> Stack; Stack.top(), Stack.pop(), Stack.push()
    ###### 처음엔 생각하지 못했던 것 : 
    ###### 아직 가격이 떨어지지 않은 것들 중에서 순서상 뒤에 있는 것들이 앞에 있는 것들보다 항상 크거나 같다.
    ###### It means 바로 앞에 있는 것과 비교 후 앞에있는게 안떨어지면 앞에 있는 것들도 안떨어진다! 
    ###### => stack에 시간 흐름을 점차 쌓아놓고 떨어진게 있을 때, 하나씩 점검하며 흐른 시간들을 저장하고 pop!

- #### 프린터
  - ###### 문제 유형 : 스택/ 큐
  - ###### 대놓고 Queue를 쓰라고하는 문제
    ###### priorities를 정렬한 vector를 하나 따로 만들었음 -> 최대값인지 확인하는 비교연산 횟수를 줄이고싶어서
      ###### 다 풀고 생각해보니, 정렬할 때 하는 연산 횟수와 비교했을 때 그리 의미있는 방법은 아닌 것 같음.
      ###### 오히려 메모리 낭비였지 싶다.
    ###### queue에 priority의 모든 원소를 push하고, 정렬되어있는 priorities 원소와 비교하여 프린트 할지말지 여부 결정
    ###### Queue 문법, queue \<int\> Queue, Queue.front(), Queue.pop(), Queue.push()
  - ###### 다른사람 풀이 참고한 부분
    ###### 전체적으로 유사하나 queue에 index를 넣음
    ###### \*max_element(A.begin(),A.end()) : algorithm 헤더 안에 있음, 포인터를 반환함
    ###### 주식가격 문제도 그렇고 stack, queue에는 주로 인덱스, 시간 등을 넣어서 사용하는 것 같다.

- #### 기능개발
  - ###### 문제 유형 : 스택/ 큐

- #### 124 나라의 숫자

- #### 탑
  - ###### 문제 유형 : 스택/ 큐

- #### 쇠막대기
  - ###### 문제 유형 : 스택/ 큐

- #### 스킬트리
  - ###### for(int j = 0; j < vector.size()-1 ; j++){ ~ }
    ###### vector가 비어있을 때, 즉 vector.size()-1이 -1일 때 반복문 내부가 실행이 안되어야 하는데, 실행이 된다!!
    ###### 이거 때문에 시간을 많이 썼다.
    ###### 원인은 vector.size()의 반환형이 unsigned_int였다는거
    ###### unsigned_int의 0에서 1을 빼니 엄청 큰 양수가되는 것이었다.
    ###### 크게 하나 배웠다..

- #### 가장 큰 수
  - ###### 문제 유형 : 정렬
  - ###### 처음엔 숫자들을 string으로 바꾸고, 정렬하고 합치는 것으로 접근
  - ###### 3과 30이 이을 때 330이 되지 않고 303이 되는 문제 발생
    ###### compare을 따로 정의해 진행
    ###### compare(string& a, string& b){return a + b > b + a}
  - ###### 추가로 모든 수가 0인 경우 00000000이 아닌 0이 출력되도록 예외처리

- #### 큰 수 만들기
  - ###### 문제 유형 : Greedy
  - ###### str.erase(a,b) 문법 : str의 index a 부터 b 개 만큼 삭제

- #### 다리를 지나는 트럭
  - ###### 문제 유형 : 스택 / 큐
  - ###### 다리를 건너고 있는 트럭들을 큐에 푸쉬 queue\<int\> on_bridge;
  - ###### 다리를 다 건넌 트럭의 수를 세는 int done을 사용
  - ###### 인덱스 오류
    ###### done + on_bridge.size()를 인덱스로 사용
    ###### 대기중인 트럭이 없을 때 done+on_bridge.size()가 모든 트럭의 수가됨

- #### 더 맵게
  - ###### 문제 유형 : 힙
  - ###### 계속해서 최소값을 찾고 반환해야하는 문제
    ###### 처음엔 sort함수로 한번 정렬하고 뒤에 계산해서 나온 새로운 값만 자리를 찾아서 넣어줬는데
    ###### 시간초과가 났다.
    ###### 하는 수 없이, 우선순위큐로 다시 풀이

- #### H-Index
  - ###### 문제 유형 : 정렬
    ###### 나중에 다시 한번 더 풀어볼 것

- #### 전화번호 목록
  - ###### 문제 유형 : 해시
  - ###### 그냥 string의 find함수로 풀어버렸다.
  
- #### 카펫
  - ###### 문제 유형 : 완전탐색

- #### 소수찾기
  - ###### 문제 유형 : 완전탐색
  - ###### 주어진 numbers를 내림차순 정렬해 만들 수 있는 가장 큰 수를 도출하고,
    ###### 그 수까지의 모든 소수를 찾고 numbers로 만들 수 있는 소수인지 확인

- #### 괄호변환
  - ###### 문제에서 시키는대로 재귀(Recursion)을 하면 되는 문제
  - ###### u에서 첫 번째와 마지막 문자를 제외하고 뒤집으라는 것을 순서를 뒤집으라는 것으로 잘못이해해 시간을 허비했다.
    ###### 잘 읽자..

- #### 올바른 괄호

- #### 피보나치 수
  - ###### 조건의 n이 100,000까지 가능하므로 효율성을 위해 DP로 접근

- #### 최솟값 만들기

- #### 최댓값과 최솟값
  - ###### strtok
    ###### c++의 string를 c의 strtok함수를 통해 tokenize해서 string 안의 정수들을 추출
    ###### c의 strtok함수는 string 클래스를 못받고 char\*을 받기 때문에, string을 char\*로 변환하는 과정이 필요했다. 
    ###### 찾아보니 string을 char의 문자열로 변환하는 함수는 string.data()함수와 string.c_str()함수가 있는데,
    ###### data함수는 string 안의 내용을 그대로 복사해주고, c_str()함수는 c의 문자열 처럼 마지막에 널 문자를 붙여준다.
    ###### 그렇기 때문에 c의 함수를 사용하기 위해 string을 변환하는 경우 c_str()이 선호됨
    ###### data함수와 c_str함수 모두 const char\*을 반환하는데, strtok는 char\*를 받기 때문에,
    ###### char\*에 string의 사이즈+1만큼 동적할당 해주고 strcpy로 내용을 복사해서 사용했다.
    
- #### 숫자의 표현
  - ###### 완전탐색으로 풀었다.
    ###### solution function의 input n은 10000 이하의 수,
    ###### 만약 Time complexity가 O(n^2) 이라면, 기본 1억회
    ###### 하지만, 1부터 n'의 합이 10000이 되는 지점은 10000보다 훨씬 작을 것,
    ###### 그러므로 완전탐색을 해도 연산횟수가 그리 많지 않을 것이다! 라고 판단.
  
- #### 다음 큰 숫자

- #### N개의 최소공배수
  - ###### 유클리드 호제법

- #### 크레인 인형뽑기 게임
  - ###### 스택으로 
